/*--------------------------------------------------------------------------
   Author: Thomas Nowotny
  
   Institute: Center for Computational Neuroscience and Robotics
              University of Sussex
	      Falmer, Brighton BN1 9QJ, UK 
  
   email to:  T.Nowotny@sussex.ac.uk
  
   initial version: 2010-02-07
  
--------------------------------------------------------------------------*/

//--------------------------------------------------------------------------
/*! \file generateCPU.cc 

  \brief Functions for generating code that will run the neuron and synapse simulations on the CPU. Part of the code generation section.

*/
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
/*!
  \brief Function that generates the code of the function the will simulate all neurons on the CPU.

*/
//--------------------------------------------------------------------------

void genHostNeuron(ostream &mos)
{
  string cppFile, s, localID;
  unsigned int nt;
  ofstream os;
  cppFile = path + tS("/") + model->name + tS("_CODE_HOST/neuron.cpp");
  os.open(cppFile.c_str());
  writeHeader(os);
  os << endl;

  // compiler/include control (include once)
  os << "#ifndef _" << model->name << "host_neuron_cpp" << endl;
  os << "#define _" << model->name << "host_neuron_cpp" << endl;
  os << endl;

  // write doxygen comment
  os << "//-------------------------------------------------------------------------" << endl;
  os << "/*! \\file neuron.cpp" << endl << endl;
  os << "\\brief File generated by GeNN for the model " << model->name << " containing host-side neuron functions." << endl;
  os << "*/" << endl;
  os << "//-------------------------------------------------------------------------" << endl;
  os << endl;


  os << "void calcNeuronsCPU(";
  for (int i = 0; i < model->neuronGrpN; i++) {
    if (model->neuronType[i] == POISSONNEURON) {
      // Note: Poisson neurons only used as input neurons; they do not 
      // receive any inputs
      os << "unsigned int *rates" << model->neuronName[i] << ", // poisson ";
      os << "\"rates\" of grp " << model->neuronName[i] << endl;
      os << "unsigned int offset" << model->neuronName[i] << ", // poisson ";
      os << "\"rates\" offset of grp " << model->neuronName[i] << endl;
    }
    if (model->receivesInputCurrent[i] >= 2) {
      os << "float *inputI" << model->neuronName[i] << ", // input current of grp " << model->neuronName[i] << endl;
    }
  }
  os << "float t)" << endl;
  os << "{" << endl;
  for (int i = 0; i < model->neuronGrpN; i++) {
    nt = model->neuronType[i];
    os << "  glbscnt" << model->neuronName[i] << " = 0;" << endl;
    if (model->neuronDelaySlots[i] == 1) {
      os << "  glbSpkEvntCnt" << model->neuronName[i] << " = 0;" << endl;
    }
    else {
      os << "  spkEvntQuePtr" << model->neuronName[i] << " = (spkEvntQuePtr" << model->neuronName[i] << " + 1) % ";
      os << model->neuronDelaySlots[i] << ";" << endl;
      os << "  glbSpkEvntCnt" << model->neuronName[i] << "[spkEvntQuePtr" << model->neuronName[i] << "] = 0;" << endl;
    }
    os << "  for (int n = 0; n < " <<  model->neuronN[i] << "; n++) {" << endl;
    for (int k = 0; k < nModels[nt].varNames.size(); k++) {
      os << "    " << nModels[nt].varTypes[k] << " l" << nModels[nt].varNames[k] << " = ";
      os << nModels[nt].varNames[k] << model->neuronName[i] << "[";
      if ((nModels[nt].varNames[k] == "V") && (model->neuronDelaySlots[i] != 1)) {
	os << "(((spkEvntQuePtr" << model->neuronName[i] << " + " << (model->neuronDelaySlots[i] - 1) << ") % ";
	os << model->neuronDelaySlots[i] << ") * " << model->neuronN[i] << ") + ";
      }
      os << "n];" << endl;
    }
    os << "    float Isyn = 0;" << endl;
    if (model->inSyn[i].size() > 0) {
      //os << "    Isyn = ";
      for (int j = 0; j < model->inSyn[i].size(); j++) {
      	for (int k = 0, l = postSynModels[model->postSynapseType[model->inSyn[i][j]]].varNames.size(); k < l; k++) {
	  os << "    " << postSynModels[model->postSynapseType[model->inSyn[i][j]]].varTypes[k] << " lps" << postSynModels[model->postSynapseType[model->inSyn[i][j]]].varNames[k] << j;
	  os << " =" <<  postSynModels[model->postSynapseType[model->inSyn[i][j]]].varNames[k] << model->synapseName[model->inSyn[i][j]] << "[n];" << endl;
      	}
	os << "    Isyn += ";
	string psCode = postSynModels[model->postSynapseType[model->inSyn[i][j]]].postSyntoCurrent;
	substitute(psCode, tS("$(inSyn)"), tS("inSyn") + model->neuronName[i]+ tS(j) +tS("[n]"));
	for (int k = 0, l = nModels[nt].varNames.size(); k < l; k++) {
	  substitute(psCode, tS("$(") + nModels[nt].varNames[k] + tS(")"),
		     tS("l") + nModels[nt].varNames[k]);
	}
	for (int k = 0, l = nModels[nt].pNames.size(); k < l; k++) {
	  substitute(psCode, tS("$(") + nModels[nt].pNames[k] + tS(")"),
		     tS("l") + nModels[nt].pNames[k]);
	}
	for (int k = 0, l = postSynModels[model->postSynapseType[model->inSyn[i][j]]].pNames.size(); k < l; k++) {
	  substitute(psCode, tS("$(") + postSynModels[model->postSynapseType[model->inSyn[i][j]]].pNames[k] + tS(")"), 
		     tS(model->postSynapsePara[model->inSyn[i][j]][k]));
	}
	for (int k = 0, l = postSynModels[model->postSynapseType[model->inSyn[i][j]]].varNames.size(); k < l; k++) {
	  substitute(psCode, tS("$(") + postSynModels[model->postSynapseType[model->inSyn[i][j]]].varNames[k] + tS(")"), 
		     tS("lps")+tS(postSynModels[model->postSynapseType[model->inSyn[i][j]]].varNames[k])+tS(j));
	}
	for (int k = 0; k < postSynModels[model->postSynapseType[model->inSyn[i][j]]].dpNames.size(); ++k)
	  substitute(psCode, tS("$(") + postSynModels[model->postSynapseType[model->inSyn[i][j]]].dpNames[k] + tS(")"), tS(model->dpsp[model->inSyn[i][j]][k]));
	os << psCode;

	/*os << "inSyn" << model->neuronName[i] << j << "[n] * (";
	  os << SAVEP(model->synapsePara[model->inSyn[i][j]][0]) << " - lV)";*/
	/*substitute(code, tS("lrate"), 
	  tS("rates") + model->neuronName[i] + tS("[n + offset") + model->neuronName[i] + tS("]"));
	*/
	/*if (j < model->inSyn[i].size() - 1) {
	  os << " + ";
	}
	else {*/
	os << ";" << endl;
	//}
      }
    }
    if (model->receivesInputCurrent[i] == 1) { // receives constant input
      if (model->synapseGrpN == 0) {
	os << "    Isyn = " << model->globalInp[i] << ";" << endl;
      }
      else {
	os << "    Isyn += " << model->globalInp[i] << ";" << endl;
      }
    }    	
    if (model->receivesInputCurrent[i] >= 2) {
      if (model->synapseGrpN == 0) {
	os << "    Isyn = (" << model->ftype << ") inputI" << model->neuronName[i] << "[n];" << endl;
      }
      else {
	os << "    Isyn += (" << model->ftype << ") inputI" << model->neuronName[i] << "[n];" << endl;
      }
    }
    os << "    // calculate membrane potential" << endl;
    string code = nModels[nt].simCode;
    for (int k = 0, l = nModels[nt].varNames.size(); k < l; k++) {
      substitute(code, tS("$(") + nModels[nt].varNames[k] + tS(")"),
		 tS("l") + nModels[nt].varNames[k]);
    }
    if (nt == POISSONNEURON) {
      substitute(code, tS("lrate"), 
		 tS("rates") + model->neuronName[i] + tS("[n + offset") + model->neuronName[i] + tS("]"));
    }
    substitute(code, tS("$(Isyn)"), tS("Isyn"));
    for (int k = 0, l = nModels[nt].pNames.size(); k < l; k++) {
      substitute(code, tS("$(") + nModels[nt].pNames[k] + tS(")"), 
		 tS(model->neuronPara[i][k]));
    }
    for (int k = 0, l = nModels[nt].dpNames.size(); k < l; k++) {
      substitute(code, tS("$(") + nModels[nt].dpNames[k] + tS(")"), 
		 tS(model->dnp[i][k]));
    }
    os << code;
    if (nModels[nt].thresholdConditionCode  == tS("")) { // no condition provided
      cerr << "Generation Error: You must provide thresholdConditionCode for neuron type :  " << model->neuronType[i]  << " used for " << model->name[i];
      exit(1);
    }
    code= nModels[nt].thresholdConditionCode;
    for (int k = 0, l = nModels[nt].varNames.size(); k < l; k++) {
      substitute(code, tS("$(") + nModels[nt].varNames[k] + tS(")"),
		 nModels[nt].varNames[k] + model->neuronName[i] + tS("[n]"));
    }
    substitute(code, tS("$(Isyn)"), tS("Isyn"));
    for (int k = 0, l = nModels[nt].pNames.size(); k < l; k++) {
      substitute(code, tS("$(") + nModels[nt].pNames[k] + tS(")"),
		 tS(model->neuronPara[i][k]));
    }
      
    for (int k = 0, l = nModels[nt].dpNames.size(); k < l; k++) {
      substitute(code, tS("$(") + nModels[nt].dpNames[k] + tS(")"),
		 tS(model->dnp[i][k]));
    }
    os << "    if (" << code << ") {" << endl;
    os << "      // register a true spike" << endl;
    os << "      glbSpk" << model->neuronName[i] << "[";
    os << "glbscnt" << model->neuronName[i] << "++] = n;" << endl;
    if (model->neuronNeedSt[i]) {
      os << "      sT" << model->neuronName[i] << "[n] = t;" << endl;
    }
    if (nModels[nt].resetCode != tS("")) {
      code = nModels[nt].resetCode;
      for (int k = 0, l = nModels[nt].varNames.size(); k < l; k++) {
	substitute(code, tS("$(") + nModels[nt].varNames[k] + tS(")"), 
		   nModels[nt].varNames[k] + model->neuronName[i] + tS("[n]"));
      }
      substitute(code, tS("$(Isyn)"), tS("Isyn"));
      for (int k = 0, l = nModels[nt].pNames.size(); k < l; k++) {
	substitute(code, tS("$(") + nModels[nt].pNames[k] + tS(")"), 
		   tS(model->neuronPara[i][k]));
      }
      for (int k = 0, l = nModels[nt].dpNames.size(); k < l; k++) {
	substitute(code, tS("$(") + nModels[nt].dpNames[k] + tS(")"), 
		   tS(model->dnp[i][k]));
      }
      os << "      // spike reset code" << endl;
      os << "      " << code << endl;
    }
    os << "    }" << endl;
    os << "    if (lV >= " << model->nSpkEvntThreshold[i] << ") {" << endl;
    os << "      // register a spike type event " << endl;
    os << "      glbSpkEvnt" << model->neuronName[i] << "[";
    if (model->neuronDelaySlots[i] != 1) {
      os << "(spkEvntQuePtr" << model->neuronName[i] << " * " << model->neuronN[i] << ") + ";
    }
    os << "glbSpkEvntCnt" << model->neuronName[i];
    if (model->neuronDelaySlots[i] != 1) {
      os << "[spkEvntQuePtr" << model->neuronName[i] << "]";
    }
    os << "++] = n;" << endl;
    os << "    }" << endl;

    for (int k = 0, l = nModels[nt].varNames.size(); k < l; k++) {
      os << "    " << nModels[nt].varNames[k] <<  model->neuronName[i] << "[";
      if ((nModels[nt].varNames[k] == "V") && (model->neuronDelaySlots[i] != 1)) {
	os << "(spkEvntQuePtr" << model->neuronName[i] << " * " << model->neuronN[i] << ") + ";
      };
      os << "n] = l" << nModels[nt].varNames[k] << ";" << endl;
    }
    for (int j = 0; j < model->inSyn[i].size(); j++) {
      string psCode = postSynModels[model->postSynapseType[model->inSyn[i][j]]].postSynDecay;
      substitute(psCode, tS("$(inSyn)"), tS("inSyn") + model->neuronName[i]+ tS(j) +tS("[n]"));
      for (int k = 0, l = postSynModels[model->postSynapseType[model->inSyn[i][j]]].pNames.size(); k < l; k++) {
	substitute(psCode, tS("$(") + postSynModels[model->postSynapseType[model->inSyn[i][j]]].pNames[k] + tS(")"), 
		   tS(model->postSynapsePara[model->inSyn[i][j]][k]));
      }		   
      for (int k = 0, l = postSynModels[model->postSynapseType[model->inSyn[i][j]]].varNames.size(); k < l; k++) {
	substitute(psCode, tS("$(") + postSynModels[model->postSynapseType[model->inSyn[i][j]]].varNames[k] + tS(")"), 
		   tS("lps")+tS(postSynModels[model->postSynapseType[model->inSyn[i][j]]].varNames[k])+tS(j));
      }
      for (int k = 0; k < postSynModels[model->postSynapseType[model->inSyn[i][j]]].dpNames.size(); ++k){
	substitute(psCode, tS("$(") + postSynModels[model->postSynapseType[model->inSyn[i][j]]].dpNames[k] + tS(")"), tS(model->dpsp[model->inSyn[i][j]][k]));
      }	
      for (int k = 0, l = nModels[nt].varNames.size(); k < l; k++) {
	substitute(psCode, tS("$(") + nModels[nt].varNames[k] + tS(")"),
		   tS("l") + nModels[nt].varNames[k]);
      }	
      for (int k = 0, l = nModels[nt].pNames.size(); k < l; k++) {
	substitute(psCode, tS("$(") + nModels[nt].pNames[k] + tS(")"),
		   tS("l") + nModels[nt].pNames[k]);
      }
      os << psCode;
			
      /*os << "    inSyn"  << model->neuronName[i] << j << "[n] *= ";
      unsigned int synID = model->inSyn[i][j];
      os << SAVEP(model->dsp[synID][0]) << ";" << endl;*/
      
      for (int k = 0, l = postSynModels[model->postSynapseType[model->inSyn[i][j]]].varNames.size(); k < l; k++) {
	os << "    " <<  postSynModels[model->postSynapseType[model->inSyn[i][j]]].varNames[k] << model->synapseName[model->inSyn[i][j]] << "[n]" << " = lps" << postSynModels[model->postSynapseType[model->inSyn[i][j]]].varNames[k] << j << ";" << endl;
      }
    }
    os << "  }" << endl;
    os << endl;
  }
  os << "}" << endl << endl;
  os << "#endif" << endl;
  os.close();
} 


//--------------------------------------------------------------------------
/*!
  \brief Function that generates code that will simulate all synapses of the model on the CPU.
*/
//--------------------------------------------------------------------------

void genHostSynapse(ostream &mos)
{
  string cppFile, s, localID, theLG;
  ofstream os;
  cppFile = path + tS("/") + model->name + tS("_CODE_HOST/synapse.cpp");
  os.open(cppFile.c_str());
  writeHeader(os);
  os << endl;

  // compiler/include control (include once)
  os << "#ifndef _" << model->name << "host_synapse_cpp" << endl;
  os << "#define _" << model->name << "host_synapse_cpp" << endl;
  os << endl;

  // write doxygen comment
  os << "//-------------------------------------------------------------------------" << endl;
  os << "/*! \\file synapse.cpp" << endl << endl;
  os << "\\brief File generated by GeNN for the model " << model->name << " containing host-side synapse and learning functions." << endl;
  os << "*/" << endl;
  os << "//-------------------------------------------------------------------------" << endl;
  os << endl;

  // Function for calculating synapse input to neurons
  // Function header
  os << "void calcSynapsesCPU(float t)" << endl;
  os << "{" << endl;
  if (model->lrnGroups > 0) {
    os << "  float dt, dg;" << endl;
  }
  os << "  int ipost, npost";
  if (model->needSynapseDelay) {
    os << ", delaySlot";
  }
  os << ";" << endl;
  os << endl;
  for (int i = 0; i < model->neuronGrpN; i++) {
    if (model->inSyn[i].size() > 0) { // there is input onto this neuron group
      for (int j = 0; j < model->inSyn[i].size(); j++) {
	unsigned int synID = model->inSyn[i][j];
	unsigned int src = model->synapseSource[synID];
	float Epre = model->synapsePara[synID][1];
	float Vslope;
	if (model->synapseType[synID] == NGRADSYNAPSE) {
	  Vslope = model->synapsePara[synID][3];
	}
	if (model->neuronDelaySlots[src] != 1) {
	  os << "  delaySlot = (spkEvntQuePtr" << model->neuronName[src] << " + ";
	  os << (int) (model->neuronDelaySlots[src] - model->synapseDelay[synID] + 1);
	  os << ") % " << model->neuronDelaySlots[src] << ";" << endl;
	}	
	os << "  for (int j = 0; j < glbSpkEvntCnt" << model->neuronName[src];
	if (model->neuronDelaySlots[src] != 1) {
	  os << "[delaySlot]";
	}
	os << "; j++) {" << endl;
	if (model->synapseConnType[synID] == SPARSE) {
	  os << "    npost = g" << model->synapseName[synID] << ".gIndInG[glbSpkEvnt" << model->neuronName[src] << "[";
	  if (model->neuronDelaySlots[src] != 1) {
	    os << "delaySlot * " << model->neuronN[src] << " + ";
	  }
	  os << "j] + 1] - g" << model->synapseName[synID] << ".gIndInG[glbSpkEvnt" << model->neuronName[src] << "[";
	  if (model->neuronDelaySlots[src] != 1) {
	    os << "delaySlot * " << model->neuronN[src] << " + ";
	  }
	  os << "j]];" << endl;
	  os << "    for (int l = 0; l < npost; l++) {" << endl;
	  os << "	     ipost = g" << model->synapseName[synID] << ".gInd[g" << model->synapseName[synID];
	  os << ".gIndInG[glbSpkEvnt" << model->neuronName[src] << "[";
	  if (model->neuronDelaySlots[src] != 1) {
	    os << "delaySlot * " << model->neuronN[src] << " + ";
	  }
	  os << "j]] + l];" << endl;
	  //os << "      cerr << \" src queue dest glbSpkEvntCnt npost: \" << j << \" \" << l << \" \" << ipost;
	  //os << \" \" << glbSpkEvntCntPN << \" \" << npost <<  endl;" << endl;
	}
	else {
	  os << "    for (int n = 0; n < " << model->neuronN[i] << "; n++) {" << endl;
	}
	if (model->synapseGType[synID] == INDIVIDUALID) {
	  os << "      unsigned int gid = (glbSpkEvnt" << model->neuronName[src] << "[";
	  if (model->neuronDelaySlots[src] != 1) {
	    os << "delaySlot * " << model->neuronN[src] << " + ";
	  }
	  os << "j] * " << model->neuronN[i] << " + n);" << endl;
	}
	if (model->neuronType[src] != POISSONNEURON) {
	  os << "      if ";
	  if (model->synapseGType[synID] == INDIVIDUALID) {
	    /*if (model->synapseConnType[synID] == SPARSE){
	      os << "((B(g" << model->synapseName[synID] << ".gp[gid >> " << logUIntSz << "], gid & ";
	      }
	      else {*/
	    os << "((B(gp" << model->synapseName[synID] << "[gid >> " << logUIntSz << "], gid & ";
	    //} 
	    os << UIntSz - 1 << ")) && ";
	  }
	  os << "(V" << model->neuronName[src] << "[";
	  if (model->neuronDelaySlots[src] != 1) {
	    os << "(delaySlot * " << model->neuronN[src] << ") + ";
	  }
        os << "glbSpkEvnt" << model->neuronName[src] << "[";
        if (model->neuronDelaySlots[src] != 1) {
          os << "(delaySlot * " << model->neuronN[src] << ") + ";
        }
        os << "j]] > " << Epre << ")";
        if (model->synapseGType[synID] == INDIVIDUALID) {
          os << ")";
        }
        os << " {" << endl;
	}
	else {
	  if (model->synapseGType[synID] == INDIVIDUALID) {
	    /*if (model->synapseConnType[synID] == SPARSE){
	      os << "          if (B(g" << model->synapseName[synID] << ".gp[gid >> " << logUIntSz << "], gid & ";
	      }
	      else{*/
	    os << "          if (B(gp" << model->synapseName[synID] << "[gid >> " << logUIntSz << "], gid & ";
	    //}
	    os << UIntSz - 1 << ")) {" << endl;
	  }
	}
	if (model->synapseConnType[synID] != SPARSE) {
	  os << "        ipost = n;" << endl;
	}
	if (model->synapseGType[synID] == INDIVIDUALG) {
	  if (model->synapseConnType[synID] == SPARSE) {
	    theLG = tS("g") + model->synapseName[synID] + tS(".gp[");
	    theLG += tS("g") + model->synapseName[synID] + tS(".gIndInG[glbSpkEvnt");
	    theLG += tS(model->neuronName[src]) + tS("[");
	    if (model->neuronDelaySlots[src] != 1) {
	      theLG += tS("delaySlot * ") + tS(model->neuronN[src]) + tS(" + ");
	    }
	    theLG += tS("j]] + l]");
	  }
	  else {
	    theLG = tS("gp") + model->synapseName[synID] + tS("[glbSpkEvnt") + model->neuronName[src] + tS("[");
	    if (model->neuronDelaySlots[src] != 1) {
	      theLG += tS("delaySlot * ") + tS(model->neuronN[src]) + tS(" + ");
	    }
	    theLG += tS("j] * ") + tS(model->neuronN[i]) + tS(" + ipost]");
	  }
	}
	if ((model->synapseGType[synID] == GLOBALG) || (model->synapseGType[synID] == INDIVIDUALID)) {
	  theLG = tS(model->g0[synID]);
	}
        if ((model->synapseType[synID] == NSYNAPSE) || (model->synapseType[synID] == LEARN1SYNAPSE)) {
	  os << "        inSyn" << model->neuronName[i] << j << "[ipost] += " << theLG << ";" << endl;
	}
	if (model->synapseType[synID] == NGRADSYNAPSE) {
	  os << "        inSyn" << model->neuronName[i] << j << "[ipost] += " << theLG << " * tanh((";
	  if (model->neuronType[src] == POISSONNEURON) {
	    os << SAVEP(model->neuronPara[src][2]) << " - " << SAVEP(Epre);
	  }
	  else {
	    os << "V" << model->neuronName[src] << "[";
	    if (model->neuronDelaySlots[src] != 1) {
	      os << "(delaySlot * " << model->neuronN[src] << ") + ";
	    }
	    os << "glbSpkEvnt" << model->neuronName[src] << "[";
	    if (model->neuronDelaySlots[src] != 1) {
	      os << "(delaySlot * " << model->neuronN[src] << ") + ";
	    }
	    os << "j]] - " << SAVEP(Epre);
	  }
	  os << ") / " << SAVEP(Vslope) << ");" << endl;
	}
	// if needed, do some learning (this is for pre-synaptic spikes)
	if (model->synapseType[synID] == LEARN1SYNAPSE) {
	  // simply assume INDIVIDUALG for now
	  os << "          dt = sT" << model->neuronName[i] << "[ipost] - t - ";
	  os << SAVEP(model->synapsePara[synID][11]) << ";" << endl;
	  os << "          if (dt > " << model->dsp[synID][1] << ") {" << endl;
	  os << "            dg = -" << SAVEP(model->dsp[synID][5]) << ";" << endl;
	  os << "          }" << endl;
	  os << "          else if (dt > 0.0) {" << endl;
	  os << "            dg = " << SAVEP(model->dsp[synID][3]) << " * dt + ";
	  os << SAVEP(model->dsp[synID][6]) << ";" << endl;
	  os << "          }" << endl;
	  os << "          else if (dt > " << model->dsp[synID][2] << ") {" << endl;
	  os << "            dg = " << SAVEP(model->dsp[synID][4]) << " * dt + ";
	  os << SAVEP(model->dsp[synID][6]) << ";" << endl;
	  os << "          }" << endl;
	  os << "          else {" << endl;
	  os << "            dg = -" << SAVEP(model->dsp[synID][7]) << ";" << endl;
	  os << "          }" << endl;
	  os << "          grawp" << model->synapseName[synID] << "[glbSpkEvnt" << model->neuronName[src] << "[";
	  if (model->neuronDelaySlots[src] != 1) {
	    os << "delaySlot * " << model->neuronN[src] << " + ";
	  }
	  os << "j] * " << model->neuronN[i] << " + ipost] += dg;" << endl;
	  if (model->synapseConnType[synID] == SPARSE) {
	    os << "          g" << model->synapseName[synID] << ".gp[glbSpkEvnt" << model->neuronName[src] << "[";
	  }
	  else {
	    os << "          gp" << model->synapseName[synID] << "[glbSpkEvnt" << model->neuronName[src] << "[";
	  }
	  if (model->neuronDelaySlots[src] != 1) {
	    os << "delaySlot * " << model->neuronN[src] << " + ";
	  }
	  os << "j] * " << model->neuronN[i] << " + n] += dg;" << endl;
	  os << "          gp" << model->synapseName[synID] << "[glbSpkEvnt" << model->neuronName[src] << "[";
	  if (model->neuronDelaySlots[src] != 1) {
	    os << "delaySlot * " << model->neuronN[src] << " + ";
	  }
	  os << "j] * " << model->neuronN[i] << " + n] = ";
	  os << "gFunc" << model->synapseName[synID] << "(grawp" << model->synapseName[synID];
	  os << "[glbSpkEvnt" << model->neuronName[src] << "[";
	  if (model->neuronDelaySlots[src] != 1) {
	    os << "delaySlot * " << model->neuronN[src] << " + ";
	  }
	  os << "j] * " << model->neuronN[i] << " + n]);" << endl; 
	}
	if ((model->neuronType[src] != POISSONNEURON) ||
	    (model->synapseGType[synID] == INDIVIDUALID)) {
	  os << "      }" << endl;
	}
	os << "    }" << endl;
	os << "  }" << endl;
      }
    }
  }
  os << "}" << endl;
  os << endl;


  if (model->lrnGroups > 0) {
    // function for learning synapses, post-synaptic spikes
    os << "void learnSynapsesPostHost(float t)" << endl;
    os << "{" << endl;
    os << "  float dt, dg;" << endl;
    os << endl;

    for (int i = 0; i < model->lrnGroups; i++) {
      unsigned int k = model->lrnSynGrp[i];
      unsigned int src = model->synapseSource[k];
      unsigned int nN = model->neuronN[src];
      unsigned int trg = model->synapseTarget[k];
      float Epre = model->synapsePara[k][1];

      os << "  for (int j = 0; j < glbSpkEvntCnt" << model->neuronName[trg];
      if (model->neuronDelaySlots[trg] != 1) {
	os << "[spkEvntQuePtr" << model->neuronName[trg] << "]" << endl;
      }
      os << "; j++) {" << endl;
      os << "    for (int n = 0; n < " << model->neuronN[src] << "; n++) {" << endl;
      os << "      if (V" << model->neuronName[trg] << "[";
      if (model->neuronDelaySlots[trg] != 1) {
	os << "(spkEvntQuePtr" << model->neuronName[trg] << " * " << model->neuronN[trg] << ") + ";
      }
      os << "glbSpkEvnt" << model->neuronName[trg] << "[";
      if (model->neuronDelaySlots[trg] != 1) {
	os << "(spkEvntQuePtr" << model->neuronName[trg] << " * " << model->neuronN[trg] << ") + ";
      }
      os << "j]] > " << Epre << ") {" << endl;
      os << "        dt = t - sT" << model->neuronName[src] << "[n]";
      if (model->neuronDelaySlots[src] != 1) {
	os << " + " << (DT * model->synapseDelay[k]);
      }
      os << " - " << SAVEP(model->synapsePara[k][11]) << ";" << endl;
      os << "        if (dt > " << model->dsp[k][1] << ") {" << endl;
      os << "          dg = -" << SAVEP(model->dsp[k][5]) << ";" << endl;
      os << "        }" << endl;
      os << "        else if (dt > 0.0) {" << endl;
      os << "          dg = " << SAVEP(model->dsp[k][3]) << " * dt + " << SAVEP(model->dsp[k][6]) << ";" << endl;
      os << "        }" << endl;
      os << "        else if (dt > " << model->dsp[k][2] << ") {" << endl;
      os << "          dg = " << SAVEP(model->dsp[k][4]) << " * dt + " << SAVEP(model->dsp[k][6]) << ";" << endl;
      os << "        }" << endl;
      os << "        else {" << endl;
      os << "          dg = -" << SAVEP(model->dsp[k][7]) << ";" << endl;
      os << "        }" << endl;
      os << "        grawp" << model->synapseName[k] << "[n * ";
      os << model->neuronN[trg] << " + glbSpkEvnt" << model->neuronName[trg] << "[";
      if (model->neuronDelaySlots[trg] != 1) {
	os << "(spkEvntQuePtr" << model->neuronName[trg] << " * " << model->neuronN[trg] << ") + ";
      }
      os << "j]] += dg;" << endl;
      if (model->synapseConnType[k] == SPARSE) {
      	os << "        g" << model->synapseName[k] << ".gp[n * ";
      }
      else {
        os << "        gp" << model->synapseName[k] << "[n * ";
      }
      os << model->neuronN[trg] << " + glbSpkEvnt" << model->neuronName[trg] << "[";
      if (model->neuronDelaySlots[trg] != 1) {
	os << "(spkEvntQuePtr" << model->neuronName[trg] << " * " << model->neuronN[trg] << ") + ";
      }
      os << "j]] = gFunc" << model->synapseName[k] << "(grawp" << model->synapseName[k] << "[n * ";
      os << model->neuronN[trg] << " + glbSpkEvnt" << model->neuronName[trg] << "[";
      if (model->neuronDelaySlots[trg] != 1) {
	os << "(spkEvntQuePtr" << model->neuronName[trg] << " * " << model->neuronN[trg] << ") + ";
      }
      os << "j]]);" << endl; 
      os << "      }" << endl;
      os << "    }" << endl;
      os << "  }" << endl;
    }
    os << "}" << endl;
  }
  os << endl;
  os << "#endif" << endl;
  os.close();
}
